---
title: "JMM(Java Memory Model)Java内存模型"
date: 2020-06-18 00:00:41.0
draft: false
type: "post"
showTableOfContents: true
tags: ["Java","虚拟机"]
---

# 1. 并发编程模型

**在命令式编程中，线程之间的通信机制有两种：共享内存和消息传递。**

**Java的并发采用的是共享内存模型，Java线程之间的通信总是隐式进行，整个通信过程对程序员完全透明(不可见)。**

# 2. Java内存模型的抽象结构

从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（MainMemory）中，每个线程都有一个私有的本地内存（LocalMemory），本地内存中存储了该线程以读/写共享变量的副本。

**本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。**

![JMM%20Java%20Memory%20Model%20Java%20a84d5546e3134a4a9d6fa3c3051083d8/Untitled.png](https://img.masaiqi.com/20200617235822.png)

**JMM屏蔽了不同处理器内存模型的差异，它在不同的处理器平台之上为Java程序员呈现了一个一致的内存模型。**

# 3. 重排序

## 3.1. 什么是重排序

**重排序是指编译器和处理器为了优化程序性能而对指令进行重新排序对一种手段。**

Java源代码到最终执行到指令序列，会分别经历下面3种重排序：

![JMM%20Java%20Memory%20Model%20Java%20a84d5546e3134a4a9d6fa3c3051083d8/Untitled%201.png](https://img.masaiqi.com/20200617235829.png)

1. **编译器优化的重排序**。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。
2. **指令级并行的重排序**。现代处理器采用了指令级并行技术（InstructionLevelParallelism，ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。
3. **内存系统的重排序**。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。

**上述的1属于编译器重排序，2和3属于处理器重排序。**

这些重排序可能会导致多线程程序出现内存可见性问题。

对于编译器重排序，JMM的编译器重排序规则会禁止特定类型的编译器重排序（不是所有的编译器重排序都要禁止）。

对于处理器重排序，JMM的处理器重排序规则会要求Java编译器在生成指令序列时，插入特定类型的内存屏障（MemoryBarriers，Intel称之为MemoryFence）指令，通过内存屏障指令来禁止特定类型的处理器重排序。

**JMM属于语言级的内存模型，它确保在不同的编译器和不同的处理器平台之上，通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证。**

## 3.2. 数据依赖性

如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间就存在数据依赖性。

数据依赖分为下列3种类型：

![JMM%20Java%20Memory%20Model%20Java%20a84d5546e3134a4a9d6fa3c3051083d8/Untitled%202.png](https://img.masaiqi.com/20200617235834.png)

只要重排序两个操作的执行顺序，程序的执行结果就会被改变。**编译器和处理器在重排序时，会遵守数据依赖性，编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序。**

特别注意的是，这里所说的**数据依赖性仅针对单个处理器中执行的指令序列和单个线程中执行的操作**，**不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑**。

## 3.3. as-if-serial语义

as-if-serial语义的意思是：**不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。**

**编译器、runtime和处理器都必须遵守as-if-serial语义。**

**为了遵守as-if-serial语义，编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果**。但是，如果操作之间不存在数据依赖关系，这些操作就可能被编译器和处理器重排序。

**最最最需要注意的，笔者这个地方之前一直没注意，这里强调的是单线程的执行结果不被改变。**

## 3.4. 顺序一致性

顺序一致性内存模型是一个理论参考模型，在设计的时候，处理器的内存模型和编程语言的内存模型都会以顺序一致性内存模型作为参照。

顺序一致性内存模型有两大特性：

- **一个线程中的所有操作必须按照程序的顺序来执行。**
- **（不管程序是否同步）所有线程都只能看到一个单一的操作执行顺序。**在顺序一致性内存模型中，每个操作都必须原子执行且立刻对所有线程可见。

**JMM对正确同步的多线程程序的内存一致性做了如下保证：**

**如果程序是正确同步的，程序的执行将具有顺序一致性（SequentiallyConsistent）——即程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同。**

## 3.5. happens-before规则

**JMM其实是在遵循一个基本原则：只要不改变程序的执行结果（指的是单线程程序和正确同步的多线程程序），编译器和处理器怎么优化都行。**

但是，JMM在优化的时候会遵循一定的规则，JSR-133用happens-before的概念指定两个操作的执行顺序。由于这两个操作可以在一个线程之内，也可以是在不同线程之间。因此，JMM可以通过happens-before关系向程序员提供跨线程的内存可见性保证（如果A线程的写操作a与B线程的读操作b之间存在happensbefore关系，尽管a操作和b操作在不同的线程中执行，但JMM向程序员保证a操作将对b操作可见）。

《JSR133 : Java Memory Model and Thread Specification》对happens-before关系的定义如下：

1. 如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。
2. 两个操作之间存在happens-before关系，并不意味着Java平台的具体实现必须要按照happens-before关系指定的顺序来执行。如果重排序之后的执行结果，与按happens-before关系来执行的结果一致，那么这种重排序并不非法（也就是说，JMM允许这种重排序）。

上面的第1点是JMM对程序员的承诺。从程序员的角度来说，可以这样理解happens-before关系：如果A happens-before B，那么Java内存模型将向程序员保证——A操作的结果将对B可见，且A的执行顺序排在B之前。注意，这只是Java内存模型向程序员做出的保证！

上面的第2点是JMM对编译器和处理器重排序的约束原则。正如前面所言，JMM其实是在遵循一个基本原则：只要不改变程序的执行结果（指的是单线程程序和正确同步的多线程程序），编译器和处理器怎么优化都行。JMM这么做的原因是：程序员对于这两个操作是否真的被重排序并不关心，程序员关心的是程序执行时的语义不能被改变（即执行结果不能被改变）。因此，happens-before关系本质上和as-if-serial语义是一回事。**as-if-serial语义保证单线程内程序的执行结果不被改变，happens-before关系保证正确同步的多线程程序的执行结果不被改变**。

说了这么多，让我们具体看一下JSR-133为我们定义的happens-before的规则：

1. **程序顺序规则**：一个线程中的每个操作，happens-before于该线程中的任意后续操作。
2. **监视器锁规则**：对一个锁的解锁，happens-before于随后对这个锁的加锁。
3. **volatile变量规则**：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。
4. **传递性**：如果AhappensbeforeB，且Bhappens-beforeC，那么A happens-before C。
5. **start()规则**：如果线程A执行操作ThreadB.start()（启动线程B），那么A线程的ThreadB.start()操作happens-before于线程B中的任意操作。
6. **join()规则**：如果线程A执行操作ThreadB.join()并成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回。

# 4. JMM的内存可见性保证

Java程序的内存可见性可以分为下列3类：

- **单线程程序。单线程程序不会出现内存可见性问题。编译器、runtime和处理器会共同确保单线程程序的执行结果与该程序在顺序一致性模型中的执行结果相同。**
- **正确同步的多线程程序。正确同步的多线程程序的执行将具有顺序一致性**（程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同）。这是JMM关注的重点，JMM通过限制编译器和处理器的重排序来为程序员提供内存可见性保证。
- **未同步/未正确同步的多线程程序。JMM为它们提供了最小安全性保障：线程执行时读取到的值，要么是之前某个线程写入的值，要么是默认值（0、null、false）。**

# 5. 参考
- 《Java并发编程的艺术》
